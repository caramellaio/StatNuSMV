diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/CMakeLists.txt
@@ -7,6 +7,7 @@
 
 option(STATIC_BINARIES "Link binaries statically." ON)
 option(USE_SORELEASE   "Use SORELEASE in shared library filename." ON)
+option(USE_ZLIB        "Use Zlib." ON)
 
 #--------------------------------------------------------------------------------------------------
 # Library version:
@@ -26,14 +27,21 @@
 #--------------------------------------------------------------------------------------------------
 # Dependencies:
 
-find_package(ZLIB)
-include_directories(${ZLIB_INCLUDE_DIR})
+if(USE_ZLIB)
+  find_package(ZLIB)
+  include_directories(${ZLIB_INCLUDE_DIR})
+  add_definitions(-DMINISAT_USE_ZLIB)
+endif()
+
 include_directories(${minisat_SOURCE_DIR})
 
 #--------------------------------------------------------------------------------------------------
 # Compile flags:
 
 add_definitions(-D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS)
+if(CMAKE_COMPILER_IS_GNUCXX)
+  add_definitions(-fPIC)
+endif()  
 
 #--------------------------------------------------------------------------------------------------
 # Build Targets:
@@ -42,13 +50,18 @@
     minisat/utils/Options.cc
     minisat/utils/System.cc
     minisat/core/Solver.cc
-    minisat/simp/SimpSolver.cc)
+    minisat/simp/SimpSolver.cc
+    minisat/proof/Proof.cc
+    minisat/simp/Solver_C.cc # NuSMV
+    )
 
 add_library(minisat-lib-static STATIC ${MINISAT_LIB_SOURCES})
 add_library(minisat-lib-shared SHARED ${MINISAT_LIB_SOURCES})
 
-target_link_libraries(minisat-lib-shared ${ZLIB_LIBRARY})
-target_link_libraries(minisat-lib-static ${ZLIB_LIBRARY})
+if(USE_ZLIB)
+  target_link_libraries(minisat-lib-shared ${ZLIB_LIBRARY})
+  target_link_libraries(minisat-lib-static ${ZLIB_LIBRARY})
+endif()  
 
 add_executable(minisat_core minisat/core/Main.cc)
 add_executable(minisat_simp minisat/simp/Main.cc)
@@ -81,3 +94,12 @@
 install(DIRECTORY minisat/mtl minisat/utils minisat/core minisat/simp
         DESTINATION include/minisat
         FILES_MATCHING PATTERN "*.h")
+
+
+### NuSMV ###################################################################
+get_target_property(_minisat_lib_loc minisat-lib-static LOCATION)
+add_custom_target(lib DEPENDS minisat-lib-static
+                  COMMAND "${CMAKE_COMMAND}" -E copy_if_different "${PROJECT_SOURCE_DIR}/minisat/simp/Solver_C.h" "${PROJECT_BINARY_DIR}/Solver_C.h"
+                  COMMAND "${CMAKE_COMMAND}" -E copy_if_different "${_minisat_lib_loc}" "${PROJECT_BINARY_DIR}/libMiniSat.a"
+                  )
+#############################################################################
diff --git a/Makefile b/Makefile
--- a/Makefile
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/Makefile
@@ -1,9 +1,29 @@
 ###################################################################################################
 
 .PHONY:	r d p sh cr cd cp csh lr ld lp lsh config all install install-headers install-lib\
-        install-bin clean distclean
+        install-bin clean distclean \
+	lib origclean
 all:	r lr lsh
 
+### NuSMV ###################################################################
+LN ?= ln -s
+NUSMV_LIBNAME = libMiniSat.a
+NUSMV_HEADER = Solver_C.h
+lib: $(NUSMV_LIBNAME) $(NUSMV_HEADER)
+	@echo Done
+
+$(NUSMV_LIBNAME): lr
+	$(LN) $(BUILD_DIR)/release/lib/$(MINISAT_SLIB) $(NUSMV_LIBNAME)
+
+$(NUSMV_HEADER): lr
+	$(LN) minisat/simp/$(NUSMV_HEADER) $(NUSMV_HEADER)
+
+clean: origclean
+	rm -f $(NUSMV_LIBNAME)
+	rm -f $(NUSMV_HEADER)
+#############################################################################
+
+
 ## Load Previous Configuration ####################################################################
 
 -include config.mk
@@ -69,8 +89,8 @@
 VERB=
 endif
 
-SRCS = $(wildcard minisat/core/*.cc) $(wildcard minisat/simp/*.cc) $(wildcard minisat/utils/*.cc)
-HDRS = $(wildcard minisat/mtl/*.h) $(wildcard minisat/core/*.h) $(wildcard minisat/simp/*.h) $(wildcard minisat/utils/*.h)
+SRCS = $(wildcard minisat/core/*.cc) $(wildcard minisat/simp/*.cc) $(wildcard minisat/utils/*.cc) $(wildcard minisat/proof/*.cc)
+HDRS = $(wildcard minisat/mtl/*.h) $(wildcard minisat/core/*.h) $(wildcard minisat/simp/*.h) $(wildcard minisat/utils/*.h) $(wildcard minisat/proof/*.h)
 OBJS = $(filter-out %Main.o, $(SRCS:.cc=.o))
 
 r:	$(BUILD_DIR)/release/bin/$(MINISAT)
@@ -89,7 +109,7 @@
 lsh:	$(BUILD_DIR)/dynamic/lib/$(MINISAT_DLIB).$(SOMAJOR).$(SOMINOR)$(SORELEASE)
 
 ## Build-type Compile-flags:
-$(BUILD_DIR)/release/%.o:			MINISAT_CXXFLAGS +=$(MINISAT_REL) $(MINISAT_RELSYM)
+$(BUILD_DIR)/release/%.o:			MINISAT_CXXFLAGS +=$(MINISAT_REL) $(MINISAT_RELSYM) $(MINISAT_FPIC)
 $(BUILD_DIR)/debug/%.o:				MINISAT_CXXFLAGS +=$(MINISAT_DEB) -g
 $(BUILD_DIR)/profile/%.o:			MINISAT_CXXFLAGS +=$(MINISAT_PRF) -pg
 $(BUILD_DIR)/dynamic/%.o:			MINISAT_CXXFLAGS +=$(MINISAT_REL) $(MINISAT_FPIC)
@@ -195,7 +215,7 @@
 	$(INSTALL) -d $(DESTDIR)$(bindir)
 	$(INSTALL) -m 755 $(BUILD_DIR)/dynamic/bin/$(MINISAT) $(DESTDIR)$(bindir)
 
-clean:
+origclean:
 	rm -f $(foreach t, release debug profile dynamic, $(foreach o, $(SRCS:.cc=.o), $(BUILD_DIR)/$t/$o)) \
           $(foreach t, release debug profile dynamic, $(foreach d, $(SRCS:.cc=.d), $(BUILD_DIR)/$t/$d)) \
 	  $(foreach t, release debug profile dynamic, $(BUILD_DIR)/$t/bin/$(MINISAT_CORE) $(BUILD_DIR)/$t/bin/$(MINISAT)) \
@@ -203,6 +223,7 @@
 	  $(BUILD_DIR)/dynamic/lib/$(MINISAT_DLIB).$(SOMAJOR).$(SOMINOR)$(SORELEASE)\
 	  $(BUILD_DIR)/dynamic/lib/$(MINISAT_DLIB).$(SOMAJOR)\
 	  $(BUILD_DIR)/dynamic/lib/$(MINISAT_DLIB)
+	rm -f $(NUSMV_LIBNAME)
 
 distclean:	clean
 	rm -f config.mk
diff --git a/minisat/core/Main.cc b/minisat/core/Main.cc
--- a/minisat/core/Main.cc
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/core/Main.cc
@@ -19,7 +19,6 @@
 **************************************************************************************************/
 
 #include <errno.h>
-#include <zlib.h>
 
 #include "minisat/utils/System.h"
 #include "minisat/utils/ParseUtils.h"
@@ -64,10 +63,11 @@
         IntOption    cpu_lim("MAIN", "cpu-lim","Limit on CPU time allowed in seconds.\n", 0, IntRange(0, INT32_MAX));
         IntOption    mem_lim("MAIN", "mem-lim","Limit on memory usage in megabytes.\n", 0, IntRange(0, INT32_MAX));
         BoolOption   strictp("MAIN", "strict", "Validate DIMACS header during parsing.", false);
+        StringOption trace("MAIN", "trace", "Write proof trace to the given file.", NULL);
         
         parseOptions(argc, argv, true);
 
-        Solver S;
+        Solver S(trace != NULL);
         double initial_time = cpuTime();
 
         S.verbosity = verb;
@@ -116,6 +116,17 @@
                 printf("Solved by unit propagation\n");
                 S.printStats();
                 printf("\n"); }
+            if (trace != NULL) {
+                FILE *out = fopen(trace, "w");
+                if (out && S.proofMgr() && S.proofMgr()->toTrace(out)) {
+                    printf("trace written to %s\n", (const char *)trace);
+                } else {
+                    printf("ERROR writing trace to %s\n", (const char *)trace);
+                }
+                if (out) {
+                    fclose(out);
+                }
+            }
             printf("UNSATISFIABLE\n");
             exit(20);
         }
@@ -125,6 +136,19 @@
         if (S.verbosity > 0){
             S.printStats();
             printf("\n"); }
+
+        if (ret == l_False && trace != NULL) {
+            FILE *out = fopen(trace, "w");
+            if (out && S.proofMgr() && S.proofMgr()->toTrace(out)) {
+                printf("trace written to %s\n", (const char *)trace);
+            } else {
+                printf("ERROR writing trace to %s\n", (const char *)trace);
+            }
+            if (out) {
+                fclose(out);
+            }
+        }        
+        
         printf(ret == l_True ? "SATISFIABLE\n" : ret == l_False ? "UNSATISFIABLE\n" : "INDETERMINATE\n");
         if (res != NULL){
             if (ret == l_True){
diff --git a/minisat/core/Solver.cc b/minisat/core/Solver.cc
--- a/minisat/core/Solver.cc
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/core/Solver.cc
@@ -51,7 +51,7 @@
 // Constructor/Destructor:
 
 
-Solver::Solver() :
+Solver::Solver(bool use_proof_logging) :
 
     // Parameters (user settable):
     //
@@ -96,23 +96,41 @@
   , remove_satisfied   (true)
   , next_var           (0)
 
+    // proof generation
+  , proof_logging(use_proof_logging)
+  , pm(NULL)
     // Resource constraints:
     //
   , conflict_budget    (-1)
   , propagation_budget (-1)
   , asynch_interrupt   (false)
-{}
+{
+    // NuSMV: MOD BEGIN
+    /* Disables "progress saving" which relies on last polarity
+       assigned to a var when branching. Polarity for us is forced to
+       be false. See http://reasoning.cs.ucla.edu/fetch.php?id=69&type=pdf
+    */
+    phase_saving = 0;
+    default_polarity = l_Undef;
+    // NuSMV: MOD END
+    
+    if (proof_logging) {
+        pm = new ProofManager(this);
+    }
+}
 
 
 Solver::~Solver()
 {
+    if (pm) {
+        delete pm;
+    }
 }
 
 
 //=================================================================================================
 // Minor methods:
 
-
 // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
 // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
 //
@@ -135,6 +153,9 @@
     user_pol .insert(v, upol);
     decision .reserve(v);
     trail    .capacity(v+1);
+    if (proof_logging) {
+        trail_pos.insert(v, -1);
+    }
     setDecisionVar(v, dvar);
     return v;
 }
@@ -162,19 +183,98 @@
     for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
         if (value(ps[i]) == l_True || ps[i] == ~p)
             return true;
-        else if (value(ps[i]) != l_False && ps[i] != p)
+        else if ((value(ps[i]) != l_False || proof_logging) && ps[i] != p)
             ps[j++] = p = ps[i];
     ps.shrink(i - j);
 
     if (ps.size() == 0)
         return ok = false;
-    else if (ps.size() == 1){
-        uncheckedEnqueue(ps[0]);
-        return ok = (propagate() == CRef_Undef);
-    }else{
-        CRef cr = ca.alloc(ps, false);
-        clauses.push(cr);
-        attachClause(cr);
+
+    if (!proof_logging) {
+        if (ps.size() == 1){
+            uncheckedEnqueue(ps[0]);
+            return ok = (propagate() == CRef_Undef);
+        }else{
+            CRef cr = ca.alloc(ps, false);
+            clauses.push(cr);
+            attachClause(cr);
+        }
+    } else {
+        // when proof logging is enabled we always need the clause
+        CRef cr = ca.alloc(ps, false); 
+        pm->store(cr, pm->mkLeaf(cr)); 
+        clauses.push(cr); 
+      
+        if (ps.size() == 1) {
+            if (value(ps[0]) == l_False) { // conflict found
+                pm->buildRefutation(cr);
+                return ok = false;
+            } else {
+                CRef confl_ref;
+
+                if (value(ps[0]) == l_Undef) {
+                    uncheckedEnqueue(ps[0], cr);
+                    confl_ref = propagate();
+                    if (confl_ref != CRef_Undef) {
+                        // conflict found by propagation
+                        pm->buildRefutation(confl_ref);
+                        return ok = false;
+                    }
+                }
+            }
+
+            return true;
+        } else {
+            Clause &c = ca[cr];
+            // Proof logging is enabled, we did not remove the false
+            // literals. Therefore, c[0] and c[1] might be false. This is
+            // bad because attachClause() assumes they are unassigned,
+            // since they are going to be watched. Therefore, we look for
+            // unassigned literals and move them at the beginning
+            for (int j = 0; j < 2; ++j) {
+                if (value(c[j]) == l_False) {
+                    for (int i = j+1; i < c.size(); ++i) {
+                        if (value(c[i]) != l_False) {
+                            Lit l = c[j];
+                            c[j] = c[i];
+                            c[i] = l;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            lbool v0 = value(c[0]), v1 = value(c[1]);
+                            
+            // if both v1 and v2 are FALSE there's a conflict...
+            if (v0 == l_False && v1 == l_False) {
+                pm->buildRefutation(cr);
+                return ok = false;
+            } else if (v0 == l_False || v1 == l_False) {
+                CRef confl_ref;
+
+                // clause is unit under current assignment. Do not setup
+                // watches, but propagate the value...
+                if (v0 == l_False) {
+                    Lit l = c[0];
+                    c[0] = c[1];
+                    c[1] = l;
+                }
+                assert(value(c[0]) == l_Undef);
+                uncheckedEnqueue(c[0], cr);
+
+                confl_ref = propagate();
+                if (confl_ref != CRef_Undef) {
+                    pm->buildRefutation(confl_ref); 
+                    return ok = false;
+                }
+
+                return ok;
+            } else { // ordinary clause
+                attachClause(cr);
+                return ok;
+            }
+        }
     }
 
     return true;
@@ -211,7 +311,16 @@
 
 void Solver::removeClause(CRef cr) {
     Clause& c = ca[cr];
-    detachClause(cr);
+    if (c.size() > 1 ) {
+        detachClause(cr);
+    }
+    
+    if (proof_logging) {
+        if (reason(var(c[0])) == cr || !pm->remove(cr)) {
+            return; // we can't really remove this
+        }
+    }
+    
     // Don't leave pointers to free'd memory!
     if (locked(c)) vardata[var(c[0])].reason = CRef_Undef;
     c.mark(1); 
@@ -233,6 +342,10 @@
         for (int c = trail.size()-1; c >= trail_lim[level]; c--){
             Var      x  = var(trail[c]);
             assigns [x] = l_Undef;
+            if (proof_logging) {
+                vardata[x].reason = CRef_Undef;
+                trail_pos[x] = -1;
+            }
             if (phase_saving > 1 || (phase_saving == 1 && c > trail_lim.last()))
                 polarity[x] = sign(trail[c]);
             insertVarOrder(x); }
@@ -250,8 +363,19 @@
 {
     Var next = var_Undef;
 
+    // NuSMV: PREF MOD
+    // Selection from preferred list
+    for (int i = 0; i < preferred.size(); i++) {
+      if (value(preferred[i]) == l_Undef) {
+        next = preferred[i];
+        break;
+      }
+    }
+    // NuSMV: PREF MOD END
+
     // Random decision:
-    if (drand(random_seed) < random_var_freq && !order_heap.empty()){
+    if (next == var_Undef && // NuSMV: PREF MOD
+        drand(random_seed) < random_var_freq && !order_heap.empty()){
         next = order_heap[irand(random_seed,order_heap.size())];
         if (value(next) == l_Undef && decision[next])
             rnd_decisions++; }
@@ -269,6 +393,8 @@
         return lit_Undef;
     else if (user_pol[next] != l_Undef)
         return mkLit(next, user_pol[next] == l_True);
+    else if (default_polarity != l_Undef) // NuSMV
+        return mkLit(next, default_polarity == l_True);
     else if (rnd_pol)
         return mkLit(next, drand(random_seed) < 0.5);
     else
@@ -293,7 +419,7 @@
 |        rest of literals. There may be others from the same level though.
 |  
 |________________________________________________________________________________________________@*/
-void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
+Proof Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
 {
     int pathC = 0;
     Lit p     = lit_Undef;
@@ -303,6 +429,13 @@
     out_learnt.push();      // (leave room for the asserting literal)
     int index   = trail.size() - 1;
 
+    if (proof_logging) {
+        proof_pivots.clear();
+        proof_antes.clear();
+
+        proof_antes.push(pm->ref(pm->proof(confl)));
+    }
+
     do{
         assert(confl != CRef_Undef); // (otherwise should be UIP)
         Clause& c = ca[confl];
@@ -313,7 +446,7 @@
         for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
             Lit q = c[j];
 
-            if (!seen[var(q)] && level(var(q)) > 0){
+            if (!seen[var(q)] && (proof_logging || level(var(q)) > 0)){
                 varBumpActivity(var(q));
                 seen[var(q)] = 1;
                 if (level(var(q)) >= decisionLevel())
@@ -330,13 +463,21 @@
         seen[var(p)] = 0;
         pathC--;
 
+        if (proof_logging && pathC > 0 && confl != CRef_Undef) {
+            proof_pivots.push(var(p));
+            proof_antes.push(pm->ref(pm->proof(confl)));
+        }
     }while (pathC > 0);
     out_learnt[0] = ~p;
 
     // Simplify conflict clause:
     //
     int i, j;
-    out_learnt.copyTo(analyze_toclear);
+    if (!proof_logging) {
+        out_learnt.copyTo(analyze_toclear);
+    } else {
+        analyze_toclear.clear();        
+    }
     if (ccmin_mode == 2){
         for (i = j = 1; i < out_learnt.size(); i++)
             if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i]))
@@ -350,10 +491,17 @@
                 out_learnt[j++] = out_learnt[i];
             else{
                 Clause& c = ca[reason(var(out_learnt[i]))];
-                for (int k = 1; k < c.size(); k++)
-                    if (!seen[var(c[k])] && level(var(c[k])) > 0){
+                for (int k = 1; k < c.size(); k++) {
+                    if (!seen[var(c[k])] &&
+                        (proof_logging || level(var(c[k])) > 0)){
                         out_learnt[j++] = out_learnt[i];
-                        break; }
+                        goto Keep;
+                    }
+                }
+                if (proof_logging) {
+                    analyze_toclear.push(out_learnt[i]);
+                }
+              Keep:;
             }
         }
     }else
@@ -363,6 +511,21 @@
     out_learnt.shrink(i - j);
     tot_literals += out_learnt.size();
 
+    if (proof_logging) {
+        sort(analyze_toclear, analyze_ccmin_lt(trail_pos));
+        enum { seen_failed = 3 };
+        for (int k = 0; k < analyze_toclear.size(); ++k) {
+            Var v = var(analyze_toclear[k]);
+            if (seen[v] != seen_failed) {
+                proof_pivots.push(v);
+                proof_antes.push(pm->ref(pm->proof(reason(v))));
+            }
+        }
+        for (int i = 0; i < out_learnt.size(); ++i) {
+            analyze_toclear.push(out_learnt[i]);
+        }    
+    }
+    
     // Find correct backtrack level:
     //
     if (out_learnt.size() == 1)
@@ -381,6 +544,21 @@
     }
 
     for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
+
+    Proof res = proof_Error;
+    if (proof_logging) {
+        if (proof_pivots.size() > 0) {
+            res = pm->mkRes(proof_pivots, proof_antes);
+        } else {
+            res = proof_antes[0];
+        }
+
+#ifdef DEBUG_PROOF_CHECK
+        assert(pm->debugCheckProof(res, out_learnt));
+#endif
+    }
+
+    return res;
 }
 
 
@@ -395,24 +573,35 @@
     vec<ShrinkStackElem>& stack = analyze_stack;
     stack.clear();
 
+    int top = analyze_toclear.size();
+
     for (uint32_t i = 1; ; i++){
         if (i < (uint32_t)c->size()){
             // Checking 'p'-parents 'l':
             Lit l = (*c)[i];
             
             // Variable at level 0 or previously removable:
-            if (level(var(l)) == 0 || seen[var(l)] == seen_source || seen[var(l)] == seen_removable){
+            if ((!proof_logging && level(var(l)) == 0) || seen[var(l)] == seen_source || seen[var(l)] == seen_removable){
                 continue; }
             
             // Check variable can not be removed for some local reason:
             if (reason(var(l)) == CRef_Undef || seen[var(l)] == seen_failed){
                 stack.push(ShrinkStackElem(0, p));
-                for (int i = 0; i < stack.size(); i++)
-                    if (seen[var(stack[i].l)] == seen_undef){
-                        seen[var(stack[i].l)] = seen_failed;
-                        analyze_toclear.push(stack[i].l);
+                for (int i = 0; i < stack.size(); i++) {
+                    Lit ll = stack[i].l;
+                    if (seen[var(ll)] == seen_undef){
+                        seen[var(ll)] = seen_failed;
+                        analyze_toclear.push(ll);
                     }
-                    
+                }
+
+                if (proof_logging) {
+                    for (int n = top; n < analyze_toclear.size(); ++n) {
+                        // TODO - find a better way
+                        seen[var(analyze_toclear[n])] = seen_failed;
+                    }
+                }
+                
                 return false;
             }
 
@@ -440,6 +629,10 @@
         }
     }
 
+    if (proof_logging) {
+        analyze_toclear.push(p);
+    }
+
     return true;
 }
 
@@ -469,6 +662,17 @@
             if (reason(x) == CRef_Undef){
                 assert(level(x) > 0);
                 out_conflict.insert(~trail[i]);
+
+                if (proof_logging) {
+                    assert(reason(var(trail[i])) == CRef_Undef);
+    
+                    vec<Lit> tmp;
+                    tmp.push(trail[i]);
+                    CRef cr = ca.alloc(tmp, false);
+
+                    pm->store(cr, pm->mkLeaf(cr));
+                    vardata[var(trail[i])].reason = cr;
+                }
             }else{
                 Clause& c = ca[reason(x)];
                 for (int j = 1; j < c.size(); j++)
@@ -489,6 +693,9 @@
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
+    if (proof_logging) {
+        trail_pos[var(p)] = trail.size()-1;
+    }    
 }
 
 
@@ -606,13 +813,15 @@
         if (satisfied(c))
             removeClause(cs[i]);
         else{
-            // Trim clause:
-            assert(value(c[0]) == l_Undef && value(c[1]) == l_Undef);
-            for (int k = 2; k < c.size(); k++)
-                if (value(c[k]) == l_False){
-                    c[k--] = c[c.size()-1];
-                    c.pop();
-                }
+            if (!proof_logging) {
+                // Trim clause:
+                assert(value(c[0]) == l_Undef && value(c[1]) == l_Undef);
+                for (int k = 2; k < c.size(); k++)
+                    if (value(c[k]) == l_False){
+                        c[k--] = c[c.size()-1];
+                        c.pop();
+                    }
+            }
             cs[j++] = cs[i];
         }
     }
@@ -620,6 +829,19 @@
 }
 
 
+// NuSMV: PREF MOD
+void Solver::addPreferred(Var v)
+{
+    preferred.push(v);
+}
+
+void Solver::clearPreferred()
+{
+    preferred.clear(0);
+}
+// NuSMV: PREF MOD END
+
+
 void Solver::rebuildOrderHeap()
 {
     vec<Var> vs;
@@ -642,8 +864,16 @@
 {
     assert(decisionLevel() == 0);
 
-    if (!ok || propagate() != CRef_Undef)
+    if (!ok) {
+        return false;
+    }
+    CRef confl = propagate();
+    if (confl != CRef_Undef) {
+        if (proof_logging) {
+            pm->buildRefutation(confl); 
+        }
         return ok = false;
+    }
 
     if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
         return true;
@@ -701,6 +931,8 @@
 |________________________________________________________________________________________________@*/
 lbool Solver::search(int nof_conflicts)
 {
+    Proof proof = proof_Error;
+    
     assert(ok);
     int         backtrack_level;
     int         conflictC = 0;
@@ -712,20 +944,39 @@
         if (confl != CRef_Undef){
             // CONFLICT
             conflicts++; conflictC++;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) {
+                if (proof_logging) {
+                    pm->buildRefutation(confl);
+                }
+                return l_False;
+            }
 
             learnt_clause.clear();
-            analyze(confl, learnt_clause, backtrack_level);
+            proof = analyze(confl, learnt_clause, backtrack_level);
             cancelUntil(backtrack_level);
 
-            if (learnt_clause.size() == 1){
-                uncheckedEnqueue(learnt_clause[0]);
-            }else{
-                CRef cr = ca.alloc(learnt_clause, true);
-                learnts.push(cr);
-                attachClause(cr);
-                claBumpActivity(ca[cr]);
-                uncheckedEnqueue(learnt_clause[0], cr);
+            if (proof_logging) {
+              assert(proof != proof_Error);
+              
+              CRef cr = ca.alloc(learnt_clause, true);
+              learnts.push(cr); 
+              
+              if (learnt_clause.size() > 1) {
+                  attachClause(cr);
+                  claBumpActivity(ca[cr]); 
+              }
+              uncheckedEnqueue(learnt_clause[0], cr);
+              pm->store(cr, proof);
+            } else {
+                if (learnt_clause.size() == 1){
+                    uncheckedEnqueue(learnt_clause[0]);
+                }else{
+                    CRef cr = ca.alloc(learnt_clause, true);
+                    learnts.push(cr);
+                    attachClause(cr);
+                    claBumpActivity(ca[cr]);
+                    uncheckedEnqueue(learnt_clause[0], cr);
+                }
             }
 
             varDecayActivity();
@@ -768,6 +1019,15 @@
                     newDecisionLevel();
                 }else if (value(p) == l_False){
                     analyzeFinal(~p, conflict);
+                    if (proof_logging) {
+                        // create the clause corresponding to the assumption
+                        vec<Lit> tmp;
+                        tmp.push(p);
+                        CRef cr = ca.alloc(tmp, true); 
+                        pm->store(cr, pm->mkLeaf(cr));
+                        learnts.push(cr);
+                        pm->buildRefutation(cr);
+                    }
                     return l_False;
                 }else{
                     next = p;
@@ -842,6 +1102,10 @@
     conflict.clear();
     if (!ok) return l_False;
 
+    if (proof_logging) {
+        pm->reset();
+    }
+
     solves++;
 
     max_learnts = nClauses() * learntsize_factor;
@@ -1007,6 +1271,11 @@
 
 void Solver::relocAll(ClauseAllocator& to)
 {
+    // begin relocation for proof logging
+    if (proof_logging) {
+        pm->beginUpdate();
+    }
+    
     // All watchers:
     //
     watches.cleanAll();
@@ -1025,7 +1294,8 @@
 
         // Note: it is not safe to call 'locked()' on a relocated clause. This is why we keep
         // 'dangling' reasons here. It is safe and does not hurt.
-        if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)]))){
+        if (reason(v) != CRef_Undef &&
+            (proof_logging || ca[reason(v)].reloced() || locked(ca[reason(v)]))){
             assert(!isRemoved(reason(v)));
             ca.reloc(vardata[v].reason, to);
         }
@@ -1036,7 +1306,11 @@
     int i, j;
     for (i = j = 0; i < learnts.size(); i++)
         if (!isRemoved(learnts[i])){
+            CRef orig = learnts[i];
             ca.reloc(learnts[i], to);
+            if (proof_logging) {
+                pm->update(learnts[i], orig);
+            }
             learnts[j++] = learnts[i];
         }
     learnts.shrink(i - j);
@@ -1045,10 +1319,19 @@
     //
     for (i = j = 0; i < clauses.size(); i++)
         if (!isRemoved(clauses[i])){
+            CRef orig = clauses[i];
             ca.reloc(clauses[i], to);
+            if (proof_logging) {
+                pm->update(clauses[i], orig);
+            }
             clauses[j++] = clauses[i];
         }
     clauses.shrink(i - j);
+
+    // end relocation for proof logging
+    if (proof_logging) {
+        pm->endUpdate();
+    }
 }
 
 
@@ -1064,3 +1347,5 @@
                ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
     to.moveTo(ca);
 }
+
+
diff --git a/minisat/core/Solver.h b/minisat/core/Solver.h
--- a/minisat/core/Solver.h
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/core/Solver.h
@@ -27,6 +27,7 @@
 #include "minisat/mtl/IntMap.h"
 #include "minisat/utils/Options.h"
 #include "minisat/core/SolverTypes.h"
+#include "minisat/proof/Proof.h"
 
 
 namespace Minisat {
@@ -39,7 +40,7 @@
 
     // Constructor/Destructor:
     //
-    Solver();
+    Solver(bool use_proof_logging=false);
     virtual ~Solver();
 
     // Problem specification:
@@ -75,6 +76,12 @@
     TrailIterator  trailBegin()   const;
     TrailIterator  trailEnd  ()   const;
 
+    // proof logging related
+    bool get_proof_logging() const { return proof_logging; }
+
+    // accessor for UNSAT proof
+    ProofManager *proofMgr() { return pm; }
+    
     void    toDimacs     (FILE* f, const vec<Lit>& assumps);            // Write CNF to file in DIMACS-format.
     void    toDimacs     (const char *file, const vec<Lit>& assumps);
     void    toDimacs     (FILE* f, Clause& c, vec<Var>& map, Var& max);
@@ -90,6 +97,19 @@
     void    setPolarity    (Var v, lbool b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
     void    setDecisionVar (Var v, bool b);  // Declare if a variable should be eligible for selection in the decision heuristic.
 
+    // NuSMV: PREF MOD
+    /*
+     * Add a variable at the end of the list of preferred variables
+     * Does not remove the variable from the standard ordering.
+     */
+    void addPreferred(Var v);
+    
+    /*
+     * Clear vector of preferred variables.
+     */
+    void clearPreferred();
+    // NuSMV: PREF MOD END
+    
     // Read state:
     //
     lbool   value      (Var x) const;       // The current value of a variable.
@@ -107,6 +127,7 @@
     //
     void    setConfBudget(int64_t x);
     void    setPropBudget(int64_t x);
+    void    setDecBudget(int64_t x);
     void    budgetOff();
     void    interrupt();          // Trigger a (potentially asynchronous) interruption of the solver.
     void    clearInterrupt();     // Clear interrupt indicator flag.
@@ -134,6 +155,8 @@
     int       ccmin_mode;         // Controls conflict clause minimization (0=none, 1=basic, 2=deep).
     int       phase_saving;       // Controls the level of phase saving (0=none, 1=limited, 2=full).
     bool      rnd_pol;            // Use random polarities for branching heuristics.
+    lbool     default_polarity; // NuSMV: default polarity for vars
+    
     bool      rnd_init_act;       // Initialize variable activities with a small random value.
     double    garbage_frac;       // The fraction of wasted memory allowed before a garbage collection is triggered.
     int       min_learnts_lim;    // Minimum number to set the learnts limit to.
@@ -198,6 +221,7 @@
     VMap<char>          polarity;         // The preferred polarity of each variable.
     VMap<lbool>         user_pol;         // The users preferred polarity of each variable.
     VMap<char>          decision;         // Declares if a variable is eligible for selection in the decision heuristic.
+    VMap<int>            trail_pos;        // for each variable, its position in the trail, or -1
     VMap<VarData>       vardata;          // Stores reason and level for each variable.
     OccLists<Lit, vec<Watcher>, WatcherDeleted, MkIndexLit>
                         watches;          // 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).
@@ -215,9 +239,20 @@
     Var                 next_var;         // Next variable to be created.
     ClauseAllocator     ca;
 
+    // NuSMV: PREF MOD
+    vec<Var>            preferred;
+    // NuSMV: PREF MOD END
+
     vec<Var>            released_vars;
     vec<Var>            free_vars;
 
+    // proof-related
+    bool proof_logging; // enable proof logging
+    friend class ProofManager;
+    ProofManager *pm;               // Proof Manager helper object
+    vec<Var> proof_pivots;
+    vec<Proof> proof_antes;
+    
     // Temporaries (to reduce allocation overhead). Each variable is prefixed by the method in which it is
     // used, exept 'seen' wich is used in several places.
     //
@@ -226,6 +261,20 @@
     vec<Lit>            analyze_toclear;
     vec<Lit>            add_tmp;
 
+    struct analyze_ccmin_lt {
+        const VMap<int> &trail_pos;
+
+        analyze_ccmin_lt(const VMap<int> &tp): trail_pos(tp) {}
+
+        bool operator()(Lit p, Lit q) const
+        {
+            assert(trail_pos[var(p)] >= 0);
+            assert(trail_pos[var(q)] >= 0);
+
+            return trail_pos[var(p)] > trail_pos[var(q)];
+        }
+    };
+
     double              max_learnts;
     double              learntsize_adjust_confl;
     int                 learntsize_adjust_cnt;
@@ -234,6 +283,7 @@
     //
     int64_t             conflict_budget;    // -1 means no budget.
     int64_t             propagation_budget; // -1 means no budget.
+    int64_t             decision_budget;    // -1 means no budget.
     bool                asynch_interrupt;
 
     // Main internal methods:
@@ -245,7 +295,7 @@
     bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
     CRef     propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
     void     cancelUntil      (int level);                                             // Backtrack until a certain level.
-    void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel);    // (bt = backtrack)
+    Proof     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel);    // (bt = backtrack)
     void     analyzeFinal     (Lit p, LSet& out_conflict);                             // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
     bool     litRedundant     (Lit p);                                                 // (helper method for 'analyze()')
     lbool    search           (int nof_conflicts);                                     // Search for a given number of conflicts.
@@ -342,7 +392,7 @@
 inline bool     Solver::addClause       (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); add_tmp.push(s); return addClause_(add_tmp); }
 
 inline bool     Solver::isRemoved       (CRef cr)         const { return ca[cr].mark() == 1; }
-inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }
+inline bool     Solver::locked          (const Clause& c) const { return (proof_logging || value(c[0]) == l_True) && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }
 inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
 
 inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
@@ -368,13 +418,15 @@
 }
 inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
 inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
+inline void     Solver::setDecBudget(int64_t x){ decision_budget = decisions + x; }
 inline void     Solver::interrupt(){ asynch_interrupt = true; }
 inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }
-inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }
+inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = decision_budget = -1; }
 inline bool     Solver::withinBudget() const {
     return !asynch_interrupt &&
            (conflict_budget    < 0 || conflicts < (uint64_t)conflict_budget) &&
-           (propagation_budget < 0 || propagations < (uint64_t)propagation_budget); }
+           (propagation_budget < 0 || propagations < (uint64_t)propagation_budget) &&
+           (decision_budget < 0 || decisions < (uint64_t)decision_budget); }
 
 // FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
 // pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
diff --git a/minisat/core/SolverTypes.h b/minisat/core/SolverTypes.h
--- a/minisat/core/SolverTypes.h
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/core/SolverTypes.h
@@ -52,7 +52,7 @@
     int     x;
 
     // Use this as a constructor:
-    friend Lit mkLit(Var var, bool sign = false);
+    friend Lit mkLit(Var var, bool sign);
 
     bool operator == (Lit p) const { return x == p.x; }
     bool operator != (Lit p) const { return x != p.x; }
@@ -61,6 +61,7 @@
 
 
 inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }
+inline  Lit  mkLit     (Var var)            { return mkLit(var, false); }
 inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
 inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 inline  bool sign      (Lit p)              { return p.x & 1; }
@@ -120,6 +121,7 @@
 inline int   toInt  (lbool l) { return l.value; }
 inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }
 
+#define MINISAT_CONSTANTS_AS_MACROS
 #if defined(MINISAT_CONSTANTS_AS_MACROS)
   #define l_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
   #define l_False (lbool((uint8_t)1))
diff --git a/minisat/mtl/Map.h b/minisat/mtl/Map.h
--- a/minisat/mtl/Map.h
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/mtl/Map.h
@@ -29,18 +29,18 @@
 // Default hash/equals functions
 //
 
+static inline uint32_t hash(uint32_t x){ return x; }
+static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }
+static inline uint32_t hash(int32_t x) { return (uint32_t)x; }
+static inline uint32_t hash(int64_t x) { return (uint32_t)x; }
+
+
 template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };
 template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };
 
 template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };
 template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };
 
-static inline uint32_t hash(uint32_t x){ return x; }
-static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }
-static inline uint32_t hash(int32_t x) { return (uint32_t)x; }
-static inline uint32_t hash(int64_t x) { return (uint32_t)x; }
-
-
 //=================================================================================================
 // Some primes
 //
diff --git a/minisat/proof/Proof.cc b/minisat/proof/Proof.cc
new file mode 100644
--- /dev/null
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/proof/Proof.cc
@@ -0,0 +1,704 @@
+/**************************************************************************************************
+
+proof.cc
+
+Proof-related interfaces and classes
+
+  This file is part of NuSMV version 2. 
+  Copyright (C) 2007 by FBK-irst. 
+  Author: Alberto Griggio <griggio@fbk.eu> 
+          Marco Pensallorto <pensallorto@fbk.eu>
+
+  NuSMV version 2 is free software; you can redistribute it and/or 
+  modify it under the terms of the GNU Lesser General Public 
+  License as published by the Free Software Foundation; either 
+  version 2 of the License, or (at your option) any later version.
+
+  NuSMV version 2 is distributed in the hope that it will be useful, 
+  but WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public 
+  License along with this library; if not, write to the Free Software 
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
+
+  For more information on NuSMV see <http://nusmv.fbk.eu>
+  or email to <nusmv-users@fbk.eu>.
+  Please report bugs to <nusmv-users@fbk.eu>.
+
+  To contact the NuSMV development board, email to <nusmv@fbk.eu>. ]
+
+**************************************************************************************************/
+#include "minisat/proof/Proof.h"
+#include "minisat/core/Solver.h"
+#include "minisat/mtl/Sort.h"
+#include "minisat/mtl/XAlloc.h"
+
+#include <assert.h>
+
+#ifdef DEBUG_PROOF_LOGGING
+#  include <iostream>
+#  define PROOFLOG(s) (std::cout << s << std::endl)
+
+namespace Minisat {
+std::ostream &operator<<(std::ostream &out, const Lit &lit);
+std::ostream &operator<<(std::ostream &out, const Clause *clause);
+std::ostream &operator<<(std::ostream &out, const Clause &clause);
+std::ostream &operator<<(std::ostream &out, const vec<Lit> &lits);
+} // namespace Minisat
+
+#else
+#  define PROOFLOG(s)
+#endif
+
+
+namespace Minisat {
+
+//-----------------------------------------------------------------------------
+// ProofManager
+//-----------------------------------------------------------------------------
+
+
+ProofManager::ProofManager(Solver *owner):
+    owner_(owner),
+    unsat_proof_(proof_Error),
+    pm_(new ProofMap()),
+    reloc_pm_(NULL)
+{
+}
+
+
+ProofManager::~ProofManager()
+{
+    assert(reloc_pm_ == NULL);
+
+    reset();
+
+    for (int i = 0; i < pm_->bucket_count(); ++i) {
+        const vec<ProofMap::Pair> &b = pm_->bucket(i);
+        for (int j = 0; j < b.size(); ++j) {
+            free(P(b[j].data));
+        }
+    }
+
+    delete pm_;
+}
+
+
+Proof ProofManager::mkLeaf(CRef cr)
+{
+    void *mem = xrealloc(NULL, sizeof(Proof_) + sizeof(Proof_::Data));
+    Proof_ *p = new (mem) Proof_(cr);
+    
+    assert(p->leaf());
+    assert(p->cref() == cr);
+        
+    return P(p);
+}
+
+
+Proof ProofManager::mkRes(const vec<Var> &pivots, const vec<Proof> &antes)
+{
+    assert(antes.size() == pivots.size()+1);
+    
+    size_t sz = pivots.size() + antes.size() + 1;
+    size_t memsz = sizeof(Proof_) + sizeof(Proof_::Data)*sz;
+    void *mem = xrealloc(NULL, memsz);
+    Proof_ *p = new (mem) Proof_(pivots, antes);
+
+#ifndef NDEBUG
+    assert(p->size() == antes.size());
+    for (int i = 0; i < antes.size(); ++i) {
+        assert(p->ante(i) == antes[i]);
+    }
+    for (int i = 0; i < pivots.size(); ++i) {
+        assert(p->pivot(i) == pivots[i]);
+    }    
+#endif
+
+    return P(p);
+}
+
+
+Proof ProofManager::ref(Proof p)
+{
+    Proof_ *r = P(p);
+    if (!r->leaf()) {
+        ++(r->nrefs_);
+    }
+    return p;
+}
+
+
+void ProofManager::unref(Proof p)
+{
+    Proof_ *r = P(p);
+    if (r->leaf()) {
+        return;
+    }
+    assert(r->nrefs_ > 0);
+
+    if (r->nrefs_ > 1) {
+        --r->nrefs_;
+        return;
+    }
+    
+    vec<Proof_ *> to_unref;
+    to_unref.push(r);
+    
+    while (to_unref.size() > 0) {
+        Proof_ *cur = to_unref.last();
+        to_unref.pop();
+        if (!cur->leaf()) {
+            --(cur->nrefs_);
+            if (!cur->nrefs_) {
+                for (int i = 0; i < cur->size(); ++i) {
+                    to_unref.push(P(cur->ante(i)));
+                }
+                free(cur);
+            }
+        }
+    }
+}
+
+
+bool ProofManager::leaf(Proof p)
+{
+    return P(p)->leaf();
+}
+
+
+const Clause *ProofManager::cls(Proof p)
+{
+    Proof_ *r = P(p);
+    if (r->leaf()) {
+        return owner_->ca.lea(r->cref());
+    }
+    return NULL;
+}
+
+
+int ProofManager::size(Proof p)
+{
+    return P(p)->size();
+}
+
+
+Var ProofManager::pivot(Proof p, int idx)
+{
+    Proof_ *r = P(p);
+    if (r->leaf()) {
+        return var_Undef;
+    }
+    return r->pivot(idx);
+}
+
+
+Proof ProofManager::ante(Proof p, int idx)
+{
+    Proof_ *r = P(p);
+    if (r->leaf()) {
+        return proof_Error;
+    }
+    return r->ante(idx);
+}
+
+
+// confl_ref is the conflicting clause with all variables
+// assigned at level zero. To build the proof, we keep resolving each
+// literal with its reason, until we get the empty clause
+void ProofManager::buildRefutation(CRef confl_ref)
+{
+    reset();
+      
+    assert(confl_ref != CRef_Undef);
+
+    PROOFLOG("Building UNSAT proof, clause: "  << owner_->ca[confl_ref]);
+
+#ifdef DEBUG_PROOF_CHECK
+    assert(debugCheckReasons());
+#endif
+
+    vec<char> seen(owner_->nVars(), 0);
+
+    vec<Proof> antes;
+    vec<Var> pivots;
+    
+    int j, trail_last = owner_->trail.size() -1;
+    
+    Lit p = lit_Undef; 
+    do {
+        assert(confl_ref != CRef_Undef); 
+        Clause &confl = owner_->ca[confl_ref];
+
+        j = 0;
+        if (p == lit_Undef) {
+            antes.push(ref(proof(confl_ref)));
+        } else {
+            ++j;
+        }
+
+        // update seen vars
+        while (j < confl.size()) {
+            seen[var(confl[j++])] = 1;
+        }
+      
+        // Select next clause to look at:
+        do {
+            if (trail_last < 0) {
+                goto finished;
+            }
+
+            p = owner_->trail[trail_last --];
+            confl_ref = owner_->reason(var(p));
+        } while (!seen[var(p)]);
+
+        if (p != lit_Undef) {
+            seen[var(p)] = 0;
+
+            PROOFLOG(" Chaining reason for p:" << p << ", @" << confl_ref);
+
+            if (confl_ref != CRef_Undef) {
+                pivots.push(var(p));
+                antes.push(ref(proof(confl_ref)));
+            }
+        }
+    } while (trail_last >= 0);
+
+  finished:
+    assert(pivots.size() > 0);
+    unsat_proof_ = mkRes(pivots, antes);
+
+#ifdef DEBUG_PROOF_CHECK
+    assert(debugCheckProof(unsat_proof_, vec<Lit>()));
+#endif
+}
+
+
+void ProofManager::reset()
+{
+    if (unsat_proof_ != proof_Error) {
+        unref(unsat_proof_);
+        unsat_proof_ = proof_Error;
+    }
+}
+
+
+void ProofManager::store(CRef cr, Proof ir)
+{
+    ProofMap &pm = (*pm_);
+
+    PROOFLOG("Storing proof for Clause @" << cr << ", " <<
+             owner_->ca[cr]);
+    assert(!pm.has(cr));
+        
+    pm.insert(cr, ir);
+}
+
+
+bool ProofManager::shared(CRef cr)
+{
+    ProofMap &pm = (*pm_);
+    if (pm.has(cr)) {
+        Proof_ *r = P(pm[cr]);
+        return (r->leaf() || r->nrefs() > 1);
+    }
+    return false;
+}
+
+
+bool ProofManager::remove(CRef cr)
+{
+    ProofMap &pm = (*pm_);
+
+    PROOFLOG("Removing proof for Clause @" << cr);
+    assert(pm.has(cr));
+        
+    Proof ir = pm[cr];
+    if (P(ir)->leaf()) {
+        return false;
+    } else {
+        pm.remove(cr); 
+        unref(ir);
+        return true;
+    }
+}
+
+
+void ProofManager::beginUpdate()
+{
+    PROOFLOG("Update transaction started, "
+             << pm_->elems() << " elements need remapping.");
+
+    assert(reloc_pm_ == NULL);
+    reloc_pm_ = new ProofMap();
+}
+
+
+void ProofManager::endUpdate()
+{
+    assert(reloc_pm_ != NULL);
+    assert(pm_ != NULL);
+
+#ifdef DEBUG_PROOF_LOGGING
+    ProofMap &pm = (*pm_);
+    if (pm.elems() > 0) {
+        PROOFLOG("Incomplete update, following elements were missing");
+
+        for (int i = pm.bucket_count() -1; 0 <= i; -- i) {
+            const vec<ProofMap::Pair> &bucket = pm.bucket(i);
+
+            for (int j = bucket.size() -1; 0 <= j; --j) {
+                const ProofMap::Pair &p = bucket[j];
+                PROOFLOG(p.key);
+            }
+        }
+
+        assert(false);
+        abort();
+    }
+#endif // DEBUG_PROOF_LOGGING
+
+    delete pm_;
+    pm_ = reloc_pm_;
+    reloc_pm_ = NULL;
+
+    PROOFLOG("Update transaction finished.");
+}
+
+
+void ProofManager::update(CRef new_cr, CRef orig_cr)
+{
+    ProofMap &orig_pm = (*pm_);
+    ProofMap &temp_pm = (*reloc_pm_);
+
+    PROOFLOG("updating @" << orig_cr << " --> @" << new_cr);
+    assert(orig_pm.has(orig_cr));
+
+    Proof ir = orig_pm[orig_cr];
+    assert(ir != proof_Error);
+
+    Proof_ *hyp = P(ir);
+    if (hyp->leaf()) {
+        assert(hyp->cref() == orig_cr);
+        hyp->set_cref(new_cr);
+    }
+
+    assert(!temp_pm.has(new_cr));
+    temp_pm.insert(new_cr, ir);
+    orig_pm.remove(orig_cr);
+}
+
+
+namespace {
+
+struct ProofHash {
+    uint32_t operator()(Proof p) const { return (uint32_t)p; }
+};
+
+} // namespace
+
+bool ProofManager::toTrace(FILE *out)
+{
+    if (unsat_proof_ == proof_Error) {
+        return false;
+    }
+    
+    Map<Proof, int, ProofHash> pids;
+    int id = 1;
+    vec<Proof> to_process;
+
+    to_process.push(unsat_proof_);
+    while (to_process.size() > 0) {
+        Proof cur = to_process.last();
+
+        if (pids.has(cur)) {
+            to_process.pop();
+            continue;
+        }
+
+        if (!leaf(cur)) {
+            bool done = true;
+            for (int i = 0, sz = size(cur); i < sz; ++i) {
+                Proof c = ante(cur, i);
+                if (!pids.has(c)) {
+                    to_process.push(c);
+                    done = false;
+                }
+            }
+
+            if (done) {
+                to_process.pop();
+                fprintf(out, "%d *", id);
+                pids.insert(cur, id++);
+
+                for (int i = 0, sz = size(cur); i < sz; ++i) {
+                    Proof c = ante(cur, i);
+                    fprintf(out, " %d", pids[c]);
+                }
+                fprintf(out, " 0\n");
+            }
+        } else {
+            to_process.pop();
+            fprintf(out, "%d", id);
+            pids.insert(cur, id++);
+
+            const Clause *cc = cls(cur);
+            assert(cc);
+            const Clause &c = *cc;
+
+            for (int i = 0; i < c.size(); ++i) {
+                fprintf(out, " %d", (var(c[i])+1) * (sign(c[i]) ? -1 : 1));
+            }
+            fprintf(out, " 0 0\n");
+        }
+    }
+
+    return true;
+}
+
+
+// Debug code, to be disabled upon release
+//
+static void sort_for_check(vec<Lit> &out);
+
+// check unsat proof
+bool ProofManager::debugCheckProof(Proof rule, const vec<Lit> &expected_result)
+{
+    vec<Lit> expected;
+    expected_result.copyTo(expected);
+    sort_for_check(expected);
+
+    PROOFLOG("Checking UNSAT proof (" << expected_result.size() <<
+             " literals expected) ... ");
+
+    vec<Proof> to_process;
+    to_process.push(rule);
+
+    typedef Map<Proof, vec<Lit> *, ProofHash> Cache;
+    Cache cache;
+
+    while (to_process.size() > 0) {
+        Proof r = to_process.last();
+        if (cache.has(r)) {
+            to_process.pop();
+            continue;
+        }
+
+        if (!leaf(r)) {
+            Proof start = ante(r, 0);
+            vec<Lit> *c1 = NULL;
+            if (!cache.has(start)) {
+                to_process.push(start);
+            } else {
+                c1 = cache[start];
+            }
+
+            bool done = (c1 != NULL);
+
+            for (int i = 1; i < size(r); ++i) {
+                Proof ir = ante(r, i);
+
+                if (!cache.has(ir)) {
+                    to_process.push(ir);
+                    done = false;
+                }
+            }
+            if (done) {
+                to_process.pop();
+                vec<Lit> *out = new vec<Lit>();
+                bool first_time = true;
+
+                for (int i = 1; i < size(r); ++i) {
+                    Var v = pivot(r, i-1);
+                    Proof ir = ante(r, i);
+              
+                    vec<Lit> *c2 = cache[ir];
+                    if (!c2) {
+                        abort();
+                    }
+                    bool pos_found = false, neg_found = false;
+                    bool err = false;
+                    for (int j = 0; j < 2; ++j) {
+                        vec<Lit> *cur = j ? c2 : c1;
+                        for (int i = 0; i < cur->size(); ++i) {
+                            err = false;
+                            Lit l = (*cur)[i];
+                            if (var(l) == v) {
+                                if (sign(l)) {
+                                    if (neg_found) err = true;
+                                    else neg_found = true;
+                                } else {
+                                    if (pos_found) err = true;
+                                    else pos_found = true;
+                                }
+                            } else {
+                                out->push(l);
+                            }
+                            if (err) break;
+                        }
+                        if (err) break;
+                    }
+                    if (!pos_found || !neg_found || err) {
+                        PROOFLOG("WRONG RESOLUTION:, c1 = "
+                                 << *c1 << ", c2 = " << *c2 << ", pivot = "
+                                 << v);
+              
+                        return false;
+                    }
+                    sort_for_check(*out);
+                    if (!first_time) {
+                        delete c1;
+                    } else {
+                        first_time = false;
+                    }
+                    c1 = out;
+                    out = new vec<Lit>();
+                }
+                if (first_time) {
+                    vec<Lit> *t = new vec<Lit>();
+                    c1->copyTo(*t);
+                    c1 = t;
+                }
+                sort_for_check(*c1);
+                cache.insert(r, c1);
+            }
+        } else {
+            to_process.pop();
+            
+            const Clause *c = cls(r);
+            assert(c);
+
+            vec<Lit> *out = new vec<Lit>();
+            for (int i = 0; i < c->size(); ++i) {
+                out->push((*c)[i]);
+            }
+
+            sort_for_check(*out);
+            cache.insert(r, out);
+        }
+    }
+
+    vec<Lit> *result = cache[rule];
+    if (expected.size() > 0) {
+        bool ok = true;
+      
+        sort(*result);
+      
+        if (expected.size() != result->size()) {
+            ok = false;
+        } else {
+            for (int i = 0; i < expected.size(); ++i) {
+                if (expected[i] != (*result)[i]) {
+                    ok = false;
+                    break;
+                }
+            }
+        }
+        if (!ok) {
+            PROOFLOG("ERROR: EXPECTED " << expected << ", GOT " << *result
+                     << " INSTEAD");
+            return false;
+        }
+    } else {
+        if (result->size()) {
+            PROOFLOG("ERROR: EXPECTED <empty>, GOT " << *result
+                     << " INSTEAD");
+            return false;
+        }
+    }
+
+    for (int i = 0; i < cache.bucket_count(); ++i) {
+        const vec<Cache::Pair> &b = cache.bucket(i);
+        for (int j = 0; j < b.size(); ++j) {
+            delete b[j].data;
+        }
+    }
+
+    PROOFLOG("OK");
+    return true;    
+}
+
+// check that for each assigned variable in the trail, a reason is available
+bool ProofManager::debugCheckReasons()
+{
+    assert(owner_->decisionLevel() == 0);
+    
+    for (int i = 0; i < owner_->trail.size(); ++i) {
+
+        if (owner_->reason(var(owner_->trail[i])) == CRef_Undef) {
+            PROOFLOG("ERROR! TRAIL:");
+            for (int j = 0; j < owner_->trail.size(); ++j) {
+                CRef cr = owner_->reason(var(owner_->trail[j]));
+                if (CRef_Undef != cr) {
+                    PROOFLOG(owner_->trail[j] << ": " << owner_->ca[cr]);
+                } else {
+                    PROOFLOG(owner_->trail[j] << ": <NULL>");
+                }
+            }
+
+            return false;
+        }
+    }
+
+    return true;
+}
+  
+// internal services
+//
+static void sort_for_check(vec<Lit> &out)
+{
+    if (out.size() > 0) {
+        sort(out);
+        int i, j;
+        for (i = j = 1; i < out.size(); ++i) {
+            if (out[i] != out[i-1]) {
+                out[j++] = out[i];
+            }
+        }
+        out.shrink(i-j);
+    }
+}
+
+
+#ifdef DEBUG_PROOF_LOGGING
+
+std::ostream &operator<<(std::ostream &out, const Lit &lit)
+{
+    out << (sign(lit) ? "~" : "") << var(lit);
+    return out;
+}
+
+
+std::ostream &operator<<(std::ostream &out, const Clause *clause)
+{
+    out << (clause->learnt() ? "L" : "") << "(";
+    for (int i = 0; i < clause->size()-1; ++i) {
+        out << (*clause)[i] << " | ";
+    }
+    out << (*clause)[clause->size()-1] << ")";
+    return out;
+}
+
+std::ostream &operator<<(std::ostream &out, const Clause &clause)
+{
+    out << (&clause);
+    return out;
+}
+
+std::ostream &operator<<(std::ostream &out, const vec<Lit> &lits)
+{
+    out << "{";
+    for (int i = 0; i < lits.size()-1; ++i) {
+        out << lits[i] << " ; ";
+    }
+    if (lits.size()) out << lits[lits.size()-1];
+    out << "}";
+    return out;
+}
+
+#endif // DEBUG_PROOF_LOGGING
+
+} // namespace Minisat
+
diff --git a/minisat/proof/Proof.h b/minisat/proof/Proof.h
new file mode 100644
--- /dev/null
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/proof/Proof.h
@@ -0,0 +1,153 @@
+// -*- C++ -*-
+
+/**************************************************************************************************
+
+proof.h
+
+Proof-related interfaces and classes
+
+  This file is part of NuSMV version 2. 
+  Copyright (C) 2007 by FBK-irst. 
+  Author: Alberto Griggio <griggio@fbk.eu> 
+          Marco Pensallorto <pensallorto@fbk.eu>
+
+  NuSMV version 2 is free software; you can redistribute it and/or 
+  modify it under the terms of the GNU Lesser General Public 
+  License as published by the Free Software Foundation; either 
+  version 2 of the License, or (at your option) any later version.
+
+  NuSMV version 2 is distributed in the hope that it will be useful, 
+  but WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public 
+  License along with this library; if not, write to the Free Software 
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
+
+  For more information on NuSMV see <http://nusmv.fbk.eu>
+  or email to <nusmv-users@fbk.eu>.
+  Please report bugs to <nusmv-users@fbk.eu>.
+
+  To contact the NuSMV development board, email to <nusmv@fbk.eu>. ]
+
+**************************************************************************************************/
+#ifndef MINISAT_PROOF_H_DEFINED
+#define MINISAT_PROOF_H_DEFINED
+
+#include "minisat/mtl/Vec.h"
+#include "minisat/mtl/Map.h"
+#include "minisat/core/SolverTypes.h"
+#include <stdio.h>
+
+//#define DEBUG_PROOF_LOGGING
+//#define DEBUG_PROOF_CHECK
+
+namespace Minisat {
+
+class Solver;
+
+typedef uintptr_t Proof;
+static const Proof proof_Error = 0;
+
+
+class ProofManager {
+public:
+    ProofManager(Solver *s);
+    ~ProofManager();
+
+    Proof mkLeaf(CRef cr);
+    Proof mkRes(const vec<Var> &pivots, const vec<Proof> &antecedents);
+    Proof ref(Proof p);
+    void unref(Proof p);
+
+    bool leaf(Proof p);
+    const Clause *cls(Proof p);
+    int size(Proof p);
+    Var pivot(Proof p, int idx);
+    Proof ante(Proof p, int idx);
+
+    void store(CRef cr, Proof ir);
+    bool shared(CRef cr);    
+    bool remove(CRef cr);
+
+    // update transaction (used by relocAll)
+    void beginUpdate();
+    void endUpdate();
+    void update(CRef new_cr, CRef orig_cr);
+
+    Proof proof(CRef cr) const
+    { 
+        ProofMap &pm = (*pm_);
+        assert(pm.has(cr));
+        
+        return pm[cr]; 
+    }
+
+    Proof proof() { return unsat_proof_; }
+
+    void buildRefutation(CRef cr);
+    void reset();
+
+    bool toTrace(FILE *out);    
+
+    bool debugCheckProof(Proof rule, const vec<Lit> &expected);
+    bool debugCheckReasons();
+
+private:
+    class Proof_ {
+    public:
+        Proof_(CRef cr):
+            cls_(cr)
+        {
+            data_[0].size = 0;
+        }
+
+        Proof_(const vec<Var> &pivots, const vec<Proof> &antes):
+            nrefs_(1)
+        {
+            data_[0].size = antes.size();
+            data_[1].ante = antes[0];
+            for (int i = 0; i < pivots.size(); ++i) {
+                data_[1+1+(i*2)].pivot = pivots[i];
+                data_[1+(i+1)*2].ante = antes[i+1];
+            }
+        }
+        
+        uint32_t nrefs() const { return leaf() ? 1 : nrefs_; }
+
+        bool leaf() const { return data_[0].size == 0; }
+
+        CRef cref() const { return cls_; }
+        void set_cref(CRef cls) { cls_ = cls; }
+
+        int size() { return data_[0].size; }
+        Var pivot(int i) { return data_[1+1+(i*2)].pivot; }
+        Proof ante(int i) { return data_[1+(i*2)].ante; }
+
+        union {
+            uint32_t nrefs_;
+            CRef cls_;
+        };
+        union Data { uint32_t size; Var pivot; Proof ante; };
+        Data data_[0];
+    };
+
+    static Proof_ *P(Proof r) { return reinterpret_cast<Proof_ *>(r); }
+    static Proof P(const Proof_ *r) { return reinterpret_cast<Proof>(r); }
+
+    // keep a ref to owner Solver to access its internal data (dirty
+    // but necessary, minimize impact on Minisat code).
+    Solver *owner_;
+    Proof unsat_proof_;
+
+    typedef Map<CRef, Proof> ProofMap;
+    typedef Map<CRef, Proof>::Pair C2R_Pair;
+    ProofMap *pm_;
+    ProofMap *reloc_pm_; // used for clause relocation
+};
+
+} // namespace Minisat
+
+#endif // MINISAT_PROOF_H_DEFINED
+
diff --git a/minisat/simp/Main.cc b/minisat/simp/Main.cc
--- a/minisat/simp/Main.cc
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/simp/Main.cc
@@ -19,7 +19,6 @@
 **************************************************************************************************/
 
 #include <errno.h>
-#include <zlib.h>
 
 #include "minisat/utils/System.h"
 #include "minisat/utils/ParseUtils.h"
diff --git a/minisat/simp/Solver_C.cc b/minisat/simp/Solver_C.cc
new file mode 100644
--- /dev/null
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/simp/Solver_C.cc
@@ -0,0 +1,346 @@
+
+/**************************************************************************************************
+
+Solver_C.C
+
+C-wrapper for Solver.C
+
+  This file is part of NuSMV version 2. 
+  Copyright (C) 2007 by FBK-irst. 
+  Author: Roberto Cavada <cavada@fbk.eu>
+
+  NuSMV version 2 is free software; you can redistribute it and/or 
+  modify it under the terms of the GNU Lesser General Public 
+  License as published by the Free Software Foundation; either 
+  version 2 of the License, or (at your option) any later version.
+
+  NuSMV version 2 is distributed in the hope that it will be useful, 
+  but WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public 
+  License along with this library; if not, write to the Free Software 
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
+
+  For more information on NuSMV see <http://nusmv.fbk.eu>
+  or email to <nusmv-users@fbk.eu>.
+  Please report bugs to <nusmv-users@fbk.eu>.
+
+  To contact the NuSMV development board, email to <nusmv@fbk.eu>. ]
+
+**************************************************************************************************/
+
+
+#include "SimpSolver.h"
+extern "C" {
+#include "Solver_C.h"
+}
+
+namespace {
+using Minisat::lbool;
+
+inline bool is_core(MiniSat_ptr s) { return s & uintptr_t(1); }
+
+Minisat::SimpSolver *simp(MiniSat_ptr s)
+{
+    return reinterpret_cast<Minisat::SimpSolver *>(s);
+}
+
+Minisat::Solver *core(MiniSat_ptr s)
+{
+    return (is_core(s) ?                                        
+            reinterpret_cast<Minisat::Solver *>(s ^ uintptr_t(1)) :
+            simp(s));
+}
+
+} // namespace
+
+extern "C" MiniSat_ptr MiniSat_Create()
+{
+  Minisat::SimpSolver *s = new Minisat::SimpSolver();
+  s->default_polarity = l_True;
+  return (MiniSat_ptr)s;
+}
+
+extern "C" void MiniSat_Delete(MiniSat_ptr ms)
+{
+  if (is_core(ms)) {
+    delete core(ms);
+  } else {
+    delete simp(ms);
+  }
+}
+
+extern "C" int MiniSat_Nof_Variables(MiniSat_ptr ms)
+{
+  return core(ms)->nVars();
+}
+
+extern "C" int MiniSat_Nof_Clauses(MiniSat_ptr ms)
+{
+  return core(ms)->nClauses();
+}
+
+/* variables are in the range 1...N */
+extern "C" int MiniSat_New_Variable(MiniSat_ptr ms)
+{
+  /* Actually, minisat used variable range 0 .. N-1,
+     so in all function below there is a convertion between
+     input variable (1..N) and internal variables (0..N-1)
+  */
+  Minisat::Var var;
+  if (is_core(ms)) {
+    var = core(ms)->newVar();
+  } else {
+    var = simp(ms)->newVar();
+    simp(ms)->setFrozen(var, true);
+  }
+  return var+1;
+}
+
+
+/*
+ * Here clauses are in dimacs form, variable indexing is 1...N
+ */
+extern "C" int MiniSat_Add_Clause(MiniSat_ptr ms,
+                                  int *clause_lits, int num_lits)
+{
+  int i;
+  Minisat::vec<Minisat::Lit> cl;
+  for(i = 0; i < num_lits; ++i) {
+    const int lit = clause_lits[i];
+    assert(abs(lit) > 0);
+    assert(abs(lit) <= MiniSat_Nof_Variables(ms));
+    int var = abs(lit) - 1;
+    cl.push((lit > 0) ? Minisat::mkLit(var) : ~ Minisat::mkLit(var));
+  }
+  if (is_core(ms)) {
+    core(ms)->addClause(cl);
+  } else {
+    simp(ms)->addClause(cl);
+  }
+
+  if (core(ms)->okay()) return 1;
+  return 0;
+}
+
+extern "C" int MiniSat_Solve(MiniSat_ptr ms)
+{
+  bool ret;
+  if (is_core(ms)) {
+    ret = core(ms)->solve();
+  } else {
+    ret = simp(ms)->solve();
+  }
+  if(ret) return 1;
+  return 0;
+}
+
+/*
+ * Here the assumption is in "dimacs form", variable indexing is 1...N
+ */
+extern "C" int MiniSat_Solve_Assume(MiniSat_ptr ms,
+				    int nof_assumed_lits,
+				    int *assumed_lits)
+{
+  int i;
+  Minisat::vec<Minisat::Lit> cl;
+
+  Minisat::Solver *c = core(ms);
+  Minisat::SimpSolver *s = simp(ms);
+  
+  Minisat::SimpSolver& solver = *((Minisat::SimpSolver*)ms);
+
+  if (is_core(ms)) {
+    c->simplify();
+    if(c->okay() == false) return 0;
+  } else {
+    s->simplify();
+    if(s->okay() == false) return 0;
+  }
+
+  assert(nof_assumed_lits >= 0);
+  for(i = 0; i < nof_assumed_lits; ++i) {
+    const int lit = assumed_lits[i];
+    assert(abs(lit) > 0);
+    assert(abs(lit) <= MiniSat_Nof_Variables(ms));
+    int var = abs(lit) - 1;
+    cl.push((lit > 0) ? Minisat::mkLit(var) : ~Minisat::mkLit(var));
+  }
+
+  if (is_core(ms)) {
+    if (c->solve(cl)) return 1;
+  } else {
+    if (s->solve(cl)) return 1;
+  }
+  return 0;
+}
+
+extern "C" int MiniSat_simplifyDB(MiniSat_ptr ms)
+{
+  if (is_core(ms)) {
+    core(ms)->simplify();
+    if (core(ms)->okay()) return 1;
+  } else {
+    simp(ms)->simplify();
+    if (simp(ms)->okay()) return 1;
+  }
+  return 0;
+}
+
+/*
+ * Here variables are numbered 1...N
+ */
+extern "C" int MiniSat_Get_Value(MiniSat_ptr ms, int var_num)
+{
+  assert(var_num > 0);
+  if(var_num > MiniSat_Nof_Variables(ms)) return -1;
+  /* minisat assigns all variables. just check */
+  assert(core(ms)->model[var_num-1] != l_Undef); 
+  
+  if(core(ms)->model[var_num-1] == l_True) return 1;
+  return 0;
+}
+
+extern "C" int MiniSat_Get_Nof_Conflict_Lits(MiniSat_ptr ms)
+{
+  return core(ms)->conflict.size();
+}
+
+extern "C" void MiniSat_Get_Conflict_Lits(MiniSat_ptr ms, int* conflict_lits)
+{
+  Minisat::LSet& cf = core(ms)->conflict;
+
+  for (int i = 0; i < cf.size(); ++i) {
+    int v = Minisat::var(~cf[i]);
+    int s = Minisat::sign(~cf[i]);
+    assert(v != Minisat::var_Undef);
+    conflict_lits[i] = (s == 0) ? (v+1) : -(v+1);
+  }
+}
+
+/** mode can be  polarity_user, polarity_rnd */
+extern "C" void MiniSat_Set_Polarity_Mode(MiniSat_ptr ms, int mode)
+{
+  assert(__polarity_unsupported != mode); 
+  if (polarity_rnd == mode) {
+    core(ms)->rnd_pol = true;
+    core(ms)->default_polarity = l_Undef;
+  }
+  else {
+    // assert(polarity_user == mode);
+    Minisat::Solver *s = core(ms);
+    s->rnd_pol = false;    
+    switch (mode) {
+    case polarity_false:
+      s->default_polarity = l_True;
+      break;
+    case polarity_true:
+      s->default_polarity = l_False;
+      break;
+    default: // polarity_user
+      s->default_polarity = l_Undef;
+      break;
+    }
+  }
+}
+
+extern "C" int MiniSat_Get_Polarity_Mode(MiniSat_ptr ms)
+{
+  Minisat::Solver *s = core(ms);
+  if (s->rnd_pol) {
+    return polarity_rnd;
+  } else if (s->default_polarity == l_True) {
+    return polarity_false;
+  } else if (s->default_polarity == l_False) {
+    return polarity_true;
+  } else {
+    return polarity_user;
+  }
+}
+
+extern "C" void MiniSat_Set_Random_Seed(MiniSat_ptr ms, double seed)
+{
+  core(ms)->random_seed = seed;
+}
+
+
+// NuSMV: PREF MOD
+/* variables are in the range 1...N */
+extern "C" void MiniSat_Set_Preferred_Variable(MiniSat_ptr ms, int x)
+{
+  /* Actually, minisat used variable range 0 .. N-1,
+     so in all function below there is a convertion between
+     input variable (1..N) and internal variables (0..N-1)
+  */
+  core(ms)->addPreferred((Minisat::Var) x);
+}
+
+extern "C" void MiniSat_Clear_Preferred_Variables(MiniSat_ptr ms)
+{
+
+  core(ms)->clearPreferred();
+}
+// NuSMV: PREF MOD END
+
+
+// proof-logging
+extern "C" MiniSat_ptr MiniSat_CreateExt(int use_proof_logging)
+{
+  if (!use_proof_logging) {
+    return MiniSat_Create();
+  } else {
+    Minisat::Solver *s = new Minisat::Solver(use_proof_logging);
+    s->default_polarity = l_True;
+    return (((MiniSat_ptr)s) | MiniSat_ptr(1));
+  }
+}
+
+
+extern "C" MiniSat_Proof MiniSat_Get_Unsat_Proof(MiniSat_ptr ms)
+{
+  return core(ms)->proofMgr()->proof();
+}
+
+
+extern "C" int MiniSat_Proof_IsRes(MiniSat_ptr ms, MiniSat_Proof p)
+{
+  return !core(ms)->proofMgr()->leaf(p);
+}
+
+
+extern "C" int MiniSat_Proof_Size(MiniSat_ptr ms, MiniSat_Proof p)
+{
+  if (core(ms)->proofMgr()->leaf(p)) {
+    return int(core(ms)->proofMgr()->cls(p)->size());
+  } else {
+    return int(core(ms)->proofMgr()->size(p));
+  }
+}
+
+
+extern "C" int MiniSat_Proof_Lit(MiniSat_ptr ms, MiniSat_Proof p, int idx)
+{
+  const Minisat::Clause &c = *(core(ms)->proofMgr()->cls(p));
+  int l = Minisat::var(c[idx])+1;
+  if (Minisat::sign(c[idx])) {
+    l = -l;
+  }
+  return l;
+}
+
+
+extern "C" void MiniSat_Proof_Res(MiniSat_ptr ms, MiniSat_Proof p, int idx,
+                                  int *out_pivot_lit, MiniSat_Proof *out_p)
+{
+  if (!core(ms)->proofMgr()->leaf(p)) {
+    if (!idx) {
+      *out_pivot_lit = 0;
+    } else {
+      Minisat::Var v = core(ms)->proofMgr()->pivot(p, idx-1);
+      *out_pivot_lit = v+1;
+    }
+    *out_p = core(ms)->proofMgr()->ante(p, idx);
+  }
+}
diff --git a/minisat/simp/Solver_C.h b/minisat/simp/Solver_C.h
new file mode 100644
--- /dev/null
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/simp/Solver_C.h
@@ -0,0 +1,84 @@
+/**************************************************************************************************
+
+Solver_C.h
+
+C-wrapper for Solver.h
+
+  This file is part of NuSMV version 2. 
+  Copyright (C) 2007 by FBK-irst. 
+  Author: Roberto Cavada <cavada@fbk.eu>
+
+  NuSMV version 2 is free software; you can redistribute it and/or 
+  modify it under the terms of the GNU Lesser General Public 
+  License as published by the Free Software Foundation; either 
+  version 2 of the License, or (at your option) any later version.
+
+  NuSMV version 2 is distributed in the hope that it will be useful, 
+  but WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public 
+  License along with this library; if not, write to the Free Software 
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
+
+  For more information on NuSMV see <http://nusmv.fbk.eu>
+  or email to <nusmv-users@fbk.eu>.
+  Please report bugs to <nusmv-users@fbk.eu>.
+
+  To contact the NuSMV development board, email to <nusmv@fbk.eu>. ]
+
+**************************************************************************************************/
+
+#ifndef SOLVER_C_h
+#define SOLVER_C_h
+
+#include <stdint.h>
+
+//=================================================================================================
+// Solver -- the main class:
+
+#define MiniSat_ptr uintptr_t
+
+enum {
+  __polarity_unsupported = -1,
+  polarity_true = 0, 
+  polarity_false = 1, 
+  polarity_user = 2,  
+  polarity_rnd = 3,
+};
+
+MiniSat_ptr MiniSat_Create();
+void MiniSat_Delete(MiniSat_ptr);
+int MiniSat_Nof_Variables(MiniSat_ptr);
+int MiniSat_Nof_Clauses(MiniSat_ptr);
+int MiniSat_New_Variable(MiniSat_ptr);
+int MiniSat_Add_Clause(MiniSat_ptr, int *clause_lits, int num_lits);
+int MiniSat_Solve(MiniSat_ptr);
+int MiniSat_Solve_Assume(MiniSat_ptr, int nof_assumed_lits, int *assumed_lits);
+int MiniSat_simplifyDB(MiniSat_ptr);
+int MiniSat_Get_Value(MiniSat_ptr, int var_num);
+int MiniSat_Get_Nof_Conflict_Lits(MiniSat_ptr ms);
+void MiniSat_Get_Conflict_Lits(MiniSat_ptr ms, int* conflict_lits);
+
+void MiniSat_Set_Polarity_Mode(MiniSat_ptr ms, int mode);
+int MiniSat_Get_Polarity_Mode(MiniSat_ptr ms);
+void MiniSat_Set_Random_Seed(MiniSat_ptr ms, double seed);
+
+// NuSMV: PREF MOD
+void MiniSat_Set_Preferred_Variable(MiniSat_ptr, int);
+void MiniSat_Clear_Preferred_Variables(MiniSat_ptr);
+// NuSMV: PREF MOD END
+
+// proof-logging
+MiniSat_ptr MiniSat_CreateExt(int use_proof_logging);
+#define MiniSat_Proof uintptr_t
+MiniSat_Proof MiniSat_Get_Unsat_Proof(MiniSat_ptr ms);
+int MiniSat_Proof_IsRes(MiniSat_ptr ms, MiniSat_Proof p);
+int MiniSat_Proof_Size(MiniSat_ptr ms, MiniSat_Proof p);
+int MiniSat_Proof_Lit(MiniSat_ptr ms, MiniSat_Proof p, int idx);
+void MiniSat_Proof_Res(MiniSat_ptr ms, MiniSat_Proof p, int idx,
+                       int *out_pivot_lit, MiniSat_Proof *out_p);
+
+//=================================================================================================
+#endif
diff --git a/minisat/utils/ParseUtils.h b/minisat/utils/ParseUtils.h
--- a/minisat/utils/ParseUtils.h
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/utils/ParseUtils.h
@@ -24,7 +24,15 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-#include <zlib.h>
+#ifdef MINISAT_USE_ZLIB
+#  include <zlib.h>
+#else
+   typedef FILE *gzFile;
+#  define gzopen(in, m) fopen(in, m)
+#  define gzdopen(fd, m) fdopen(fd, m)
+#  define gzread(in, buf, sz) fread(buf, 1, sz, in)
+#  define gzclose(in) fclose(in)
+#endif // MINISAT_USE_ZLIB
 
 #include "minisat/mtl/XAlloc.h"
 
diff --git a/minisat/utils/System.cc b/minisat/utils/System.cc
--- a/minisat/utils/System.cc
+++ minisat-37dc6c67e2af26379d88ce349eb9c4c6160e8543/minisat/utils/System.cc
@@ -77,7 +77,7 @@
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_maxrss / 1024; }
-double Minisat::memUsedPeak() { return memUsed(); }
+double Minisat::memUsedPeak(bool strictlyPeak) { return memUsed(); }
 
 
 #elif defined(__APPLE__)
@@ -87,11 +87,11 @@
     malloc_statistics_t t;
     malloc_zone_statistics(NULL, &t);
     return (double)t.max_size_in_use / (1024*1024); }
-double Minisat::memUsedPeak() { return memUsed(); }
+double Minisat::memUsedPeak(bool strictlyPeak) { return memUsed(); }
 
 #else
 double Minisat::memUsed()     { return 0; }
-double Minisat::memUsedPeak() { return 0; }
+double Minisat::memUsedPeak(bool strictlyPeak) { return 0; }
 #endif
 
 
